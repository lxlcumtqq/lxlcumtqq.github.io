<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python</title>
      <link href="/posts/2765404344/"/>
      <url>/posts/2765404344/</url>
      
        <content type="html"><![CDATA[<p> <strong>Redis</strong></p><ol><li>支持的数据类型</li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list set zset(有序集合)  hash string</span><br></pre></td></tr></table></figure><ol start="2"><li>基本命令</li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">select 数字 <span class="comment">#切换数据库</span></span><br><span class="line">setring的命令</span><br><span class="line">set key value  <span class="comment">#存取</span></span><br><span class="line">   setex key secodns value <span class="comment">#存取能设置时间</span></span><br><span class="line">    mset key value key value <span class="comment">#存取多个值</span></span><br><span class="line">    append key value <span class="comment">#追加</span></span><br><span class="line">    get key <span class="comment">#取值</span></span><br><span class="line">    mget key <span class="comment">#取多个值</span></span><br><span class="line">    exists key <span class="comment">#查看键是否存在</span></span><br><span class="line">    keys * 或者 a* 都可以查看键 后一种是查看包含</span><br><span class="line">    <span class="keyword">del</span> key key <span class="comment">#删除键</span></span><br><span class="line">    ttl key   <span class="comment">#查看有效时间</span></span><br><span class="line">hash的命令</span><br><span class="line">hset 键 键的属性(也就是字段) 值</span><br><span class="line">    hmset 键 建的属性 值 建 建的属性 值</span><br><span class="line">    hkeys key <span class="comment">#获取指定键的属性</span></span><br><span class="line">    hget key 键的属性 <span class="comment">#获取值</span></span><br><span class="line">    hmget  <span class="comment">#获取多个值</span></span><br><span class="line">    hvals key <span class="comment">#获取某个键的所有属性的值</span></span><br><span class="line">    hdel key 属性 <span class="comment">#删除对应的hash </span></span><br><span class="line">list的命令</span><br><span class="line">lpush key value value <span class="comment">#给列表左侧加值</span></span><br><span class="line">     rpush key value value <span class="comment">#给列表右侧加值</span></span><br><span class="line">    linsert key before或after <span class="comment">#现有元素 新元素 </span></span><br><span class="line">    lrange key start(开始)stop(结尾)<span class="comment">#获取所有元素</span></span><br><span class="line">    lset key 索引 修改的值 <span class="comment">#修改指定位置的值</span></span><br><span class="line">    lrem key 值 <span class="comment">#删除值</span></span><br><span class="line"> set的命令</span><br><span class="line">sadd key 值 <span class="comment">#添加</span></span><br><span class="line">    smembers key <span class="comment">#获取所有元素</span></span><br><span class="line">    srem key <span class="comment">#删除指定元素</span></span><br><span class="line">  zset的命令</span><br><span class="line">zadd key 权重 值 <span class="comment">#添加元素可以添加多个</span></span><br><span class="line">    zrange key start stop <span class="comment">#获取值</span></span><br><span class="line">zscore key 元素<span class="comment">#获取当前元素的权重</span></span><br><span class="line">    zrem key 元素 <span class="comment">#删除当前键中的指定元素</span></span><br><span class="line">    zremrangebyscore key min max(权重的最大和最小)<span class="comment">#删除当前集合中的权重在这个范围的元素</span></span><br></pre></td></tr></table></figure><p>3.在python用法</p><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">sr=redis.StrictRedis(host=<span class="string">"127.0.0.1"</span>,port=<span class="string">"6379"</span>,db=<span class="number">0</span>)<span class="comment">#连接reids数据库</span></span><br><span class="line">ret=sr.set(<span class="string">"a"</span>,<span class="string">"name"</span>)<span class="comment">#字符串存值</span></span><br><span class="line">print(sr.type(<span class="string">"a"</span>))<span class="comment">#查看存储类型</span></span><br><span class="line">print(sr.get(<span class="string">"a"</span>).decode(<span class="string">"utf-8"</span>))<span class="comment">#从redis取出来的值是beyts类型的用decode()的解码</span></span><br><span class="line">sr.set(<span class="string">"a"</span>,<span class="string">"list"</span>)<span class="comment">#字符串存值</span></span><br><span class="line">print(sr.get(<span class="string">"a"</span>).decode(<span class="string">"utf-8"</span>))<span class="comment">#用同一个值存数据覆盖</span></span><br><span class="line">sr.delete(<span class="string">"a"</span>)<span class="comment">#删除键</span></span><br><span class="line">print(sr.keys())<span class="comment">#查看所有的键</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>redis是单进程单线程的,redis利用队列技术将并发访问变成串行访问,消除了传统数据库串行控制的开销  因为多线程会涉及到锁,而且多线程处理会频繁切换cpu 会影响效率</p></li><li><p>redis的优势</p><p>1.速度快,因为存在内存中 查找的时间复杂度为0(1)</p><p>2.支持丰富的数据类型</p><p>3.支持事务,操作的都是原子性</p><p>4.丰富的特性:可用于缓存,消息 是指过期时间</p></li></ol><ol start="6"><li>redis主要提供的两种 持久化机制: RDB和aof</li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RDB 是一种快照存储持久化方式，具体就是将 Redis 某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为 dump.rdb，而在 Redis 服务器启动时，会重新加载 dump.rdb 文件的数据到内存当中恢复数据。</span><br><span class="line">开启 RDB 持久化方式很简单，客户端可以通过向 Redis 服务器发送 Save 或 Bgsave 命令让服务器生成 RDB 文件，或者通过服务器配置文件指定触发 RDB 条件。</span><br><span class="line">当客户端向服务器发送 Save 命令请求进行持久化时，服务器会阻塞 Save 命令之后的其他客户端的请求，直到数据同步完成。</span><br><span class="line">如果数据量太大，同步数据会执行很久，而这期间 Redis 服务器也无法接收其他请求，所以，最好不要在生产环境使用 Save 命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</span><br><span class="line">AOF 的优缺点</span><br><span class="line">优点：数据的完整性和一致性更高 ,只是追加日志文件,因此对服务器的性能影响小,速度比Rdb要快,消耗的内存较少</span><br><span class="line">缺点：因为AOF记录的内容多，日志文件会越来越大，数据恢复也会越来越慢</span><br><span class="line">RDB 的优缺点</span><br><span class="line">优点：</span><br><span class="line"><span class="number">1</span> 适合大规模的数据恢复。</span><br><span class="line"><span class="number">2</span> 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</span><br><span class="line"><span class="number">3</span> 通过Rdb进行数据备份,由于使用子进程生成,所以对Redis服务器性能影响小</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span> 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。</span><br><span class="line"><span class="number">2</span> 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。</span><br><span class="line">所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</span><br></pre></td></tr></table></figure><ol start="7"><li>redis的哨兵机制</li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</span><br><span class="line"></span><br><span class="line">监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。</span><br><span class="line"></span><br><span class="line">提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</span><br><span class="line"></span><br><span class="line">自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、保证高可用</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、监控各个节点</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、自动故障迁移</span><br><span class="line"></span><br><span class="line">缺点：主从模式，切换需要时间丢数据</span><br><span class="line"></span><br><span class="line">没有解决 master 写的压力</span><br></pre></td></tr></table></figure><ol start="8"><li>Redis的主从复制</li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis的主从复制机制是指可以让服务器(slave)能精准复制主服务器(master)的数据</span><br><span class="line">   Redis 的主从复制是异步复制，异步分为两个方面：</span><br><span class="line">   一个是 Master 服务器在将数据同步到 Slave 时是异步的，因此 Master 服务器在这里仍然可以接收其他请求。</span><br><span class="line">   一个是 Slave 在接收同步数据也是异步的。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Redis 主从复制分为以下三种方式：</span><br><span class="line">   当 Master 服务器与 Slave 服务器正常连接时，Master 服务器会发送数据命令流给 Slave 服务器，将自身数据的改变复制到 Slave 服务器。</span><br><span class="line">   </span><br><span class="line">   当因为各种原因 Master 服务器与 Slave 服务器断开后，Slave 服务器在重新连上 Master 服务器时会尝试重新获取断开后未同步的数据即部分同步，或者称为部分复制。</span><br><span class="line">   </span><br><span class="line">   如果无法部分同步（比如初次同步），则会请求进行全量同步，这时 Master 服务器会将自己的 RDB 文件发送给 Slave 服务器进行数据同步，并记录同步期间的其他写入，再发送给 Slave 服务器，以达到完全同步的目的，这种方式称为全量复制。</span><br></pre></td></tr></table></figure>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</span><br><span class="line">解决方案:</span><br><span class="line">    最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</span><br><span class="line">    另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。(只要数据库没查到，就写一个空值到缓存，下次还有这个请求，就可以走缓存了)简单回答</span><br><span class="line"></span><br><span class="line">缓存雪崩对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。是指我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</span><br><span class="line">解决方案:</span><br><span class="line">    缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如<span class="number">1</span><span class="number">-5</span>分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓存击穿:对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</span><br><span class="line">    </span><br><span class="line">解决方案:使用互斥锁 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1243066710/"/>
      <url>/posts/1243066710/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
